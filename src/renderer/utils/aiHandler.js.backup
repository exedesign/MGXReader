/**
 * AIHandler - Unified AI Gateway
 * Supports: OpenAI, Google Gemini, Local AI (Ollama/LM Studio)
 */

import axios from 'axios';
import { splitTextForAnalysis, getOptimalChunkSize } from './textProcessing.js';
import { createEnhancedAnalysisEngine } from './enhancedAnalysisEngine.js';

// Set global axios timeout to prevent default 18s timeout
axios.defaults.timeout = 300000; // 5 minutes

export const AI_PROVIDERS = {
  OPENAI: 'openai',
  GEMINI: 'gemini',
  LOCAL: 'local',
  MLX: 'mlx',
};

export const OPENAI_MODELS = [
  { id: 'gpt-4o', name: 'GPT-4o', contextWindow: 128000, recommended: true },
  { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', contextWindow: 128000 },
  { id: 'gpt-4', name: 'GPT-4', contextWindow: 8192 },
  { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', contextWindow: 16385 },
];

export const GEMINI_MODELS = [
  // Gemini 3 Series - EN AKILLI MODELLER
  { id: 'gemini-3-pro-preview', name: 'Gemini 3 Pro Preview üåü', contextWindow: 2000000, maxOutput: 8192, description: 'En akƒ±llƒ± model - √áok formatlƒ± anlama konusunda d√ºnyanƒ±n en iyisi', recommended: true },

  // Gemini 2.5 Series - HIZLI VE AKILLI
  { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash ‚ö°', contextWindow: 1000000, maxOutput: 8192, fast: true, description: 'Fiyat-performans a√ßƒ±sƒ±ndan en iyi - Hƒ±zlƒ± ve √ßok y√∂nl√º' },
  { id: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash-Lite üöÄ', contextWindow: 1000000, maxOutput: 8192, fast: true, description: 'Ultra hƒ±zlƒ± - Maliyet verimliliƒüi i√ßin optimize edilmi≈ü' },
  { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro üß†', contextWindow: 2000000, maxOutput: 8192, description: 'Geli≈ümi≈ü d√º≈ü√ºnme - Kod, matematik ve STEM problemleri i√ßin' },

  // Gemini 2.0 Series - ƒ∞Kƒ∞NCƒ∞ NESƒ∞L
  { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash', contextWindow: 1000000, maxOutput: 8192, fast: true, description: 'ƒ∞kinci nesil √ßalƒ±≈ükan model' },
  { id: 'gemini-2.0-flash-lite', name: 'Gemini 2.0 Flash-Lite', contextWindow: 1000000, maxOutput: 8192, fast: true, description: 'ƒ∞kinci nesil k√º√ß√ºk ve g√º√ßl√º model' },

  // Gemini 1.5 Series - KARAR LI MODELLER
  { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', contextWindow: 2000000, maxOutput: 8192, description: 'Kararlƒ± ve g√º√ßl√º model' },
  { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash', contextWindow: 1000000, maxOutput: 8192, fast: true, description: 'Hƒ±zlƒ± ve ekonomik' },
];

// Image Generation Models - Verified Available (https://ai.google.dev/gemini-api/docs/image-generation)
export const GEMINI_IMAGE_MODELS = [
  // Gemini Native Image Generation - NANO BANANA & NANO BANANA PRO (ACTIVE)
  { id: 'gemini-3-pro-image-preview', name: 'Gemini 3 Pro Image Preview üçå Pro', description: 'Profesyonel g√∂rsel √ºretim - 14 referans g√∂rsel, 4K √ß√∂z√ºn√ºrl√ºk, Google Search', recommended: true, maxReferenceImages: 14, maxResolution: '4K', features: ['google_search', 'thinking_mode', 'multi_turn'] },
  { id: 'gemini-2.5-flash-image', name: 'Gemini 2.5 Flash Image üçå', description: 'Hƒ±zlƒ± ve verimli g√∂rsel √ºretim - 3 referans g√∂rsel, 1K √ß√∂z√ºn√ºrl√ºk', fast: true, maxReferenceImages: 3, maxResolution: '1K' },

  // Imagen 4.0 Series - DEPRECATED (API tarafƒ±ndan desteklenmiyor)
  { id: 'imagen-4.0-generate-001', name: 'Imagen 4.0 Standard ‚ö†Ô∏è Deprecated', description: 'API tarafƒ±ndan desteklenmiyor - Gemini modelleri kullanƒ±n', deprecated: true, disabled: true },
  { id: 'imagen-4.0-fast-generate-001', name: 'Imagen 4.0 Fast ‚ö†Ô∏è Deprecated', description: 'API tarafƒ±ndan desteklenmiyor - Gemini modelleri kullanƒ±n', deprecated: true, disabled: true },
  { id: 'imagen-4.0-ultra-generate-001', name: 'Imagen 4.0 Ultra ‚ö†Ô∏è Deprecated', description: 'API tarafƒ±ndan desteklenmiyor - Gemini modelleri kullanƒ±n', deprecated: true, disabled: true },

  // Imagen 3.0 Series - LEGACY (Sƒ±nƒ±rlƒ± destek)
  { id: 'imagen-3.0-generate-001', name: 'Imagen 3.0 ‚ö†Ô∏è Legacy', description: 'Eski nesil model - Yeni projeler i√ßin Gemini √∂nerilir', deprecated: true },
];

// Image Understanding Models - Verified Available (https://ai.google.dev/gemini-api/docs/image-understanding)
export const GEMINI_IMAGE_UNDERSTANDING_MODELS = [
  // Gemini 3 Series - EN AKILLI
  { id: 'gemini-3-pro-preview', name: 'Gemini 3 Pro Preview üåü', description: 'En akƒ±llƒ± √ßok formatƒ± model - G√∂rsel a√ßƒ±klama, sƒ±nƒ±flandƒ±rma, soru-yanƒ±t', recommended: true, features: ['caption', 'classification', 'vqa', 'ocr'] },

  // Gemini 2.5 Series
  { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash ‚ö°', description: 'Hƒ±zlƒ± g√∂rsel anlama - 3600 g√∂rsel/istek', fast: true, maxImages: 3600, features: ['segmentation', 'object_detection'] },
  { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro üß†', description: 'Geli≈ümi≈ü g√∂rsel analiz - Segmentasyon ve nesne algƒ±lama', features: ['segmentation', 'object_detection', 'spatial_understanding'] },

  // Gemini 2.0 Series
  { id: 'gemini-2.0-flash', name: 'Gemini 2.0 Flash', description: 'Geli≈ümi≈ü nesne algƒ±lama - ƒ∞kinci nesil', features: ['object_detection'], maxImages: 3600 },

  // Gemini 1.5 Series
  { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', description: 'Kararlƒ± √ßok formatƒ± model', stable: true, maxImages: 3600 },
  { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash', description: 'Hƒ±zlƒ± ve ekonomik g√∂rsel anlama', fast: true, stable: true, maxImages: 3600 },
];

// OpenAI image models for comparison
export const OPENAI_IMAGE_MODELS = [
  { id: 'dall-e-3', name: 'DALL-E 3', recommended: true, description: 'OpenAI en gelismis gorsel modeli' },
  { id: 'dall-e-2', name: 'DALL-E 2', description: 'Onceki nesil DALL-E modeli' },
];

// MLX Local Models
export const MLX_MODELS = [
  { id: 'mlx-community/Llama-3.2-3B-Instruct-4bit', name: 'Llama 3.2 3B (4-bit)', contextWindow: 8192, recommended: true },
  { id: 'mlx-community/Llama-3.1-8B-Instruct-4bit', name: 'Llama 3.1 8B (4-bit)', contextWindow: 16384 },
  { id: 'mlx-community/Qwen2.5-7B-Instruct-4bit', name: 'Qwen 2.5 7B (4-bit)', contextWindow: 32768 },
];

class AIHandler {
  constructor(config = {}) {
    this.provider = config.provider || AI_PROVIDERS.OPENAI;
    this.openaiApiKey = config.openaiApiKey || '';
    // Handle both apiKey and geminiApiKey for backward compatibility
    this.apiKey = config.apiKey || config.geminiApiKey || '';
    this.model = config.model || (config.provider === AI_PROVIDERS.GEMINI ? 'gemini-3-pro-preview' : 'gpt-4o');
    
    // CRITICAL: Use provider-specific image model from config
    // This MUST match the model selected in AI Settings
    if (config.provider === AI_PROVIDERS.GEMINI) {
      this.geminiImageModel = config.imageModel || 'gemini-2.5-flash-image';
      this.imageModel = this.geminiImageModel; // Alias for compatibility
      console.log('üéØ AIHandler initialized with Gemini image model:', this.geminiImageModel);
    } else if (config.provider === AI_PROVIDERS.OPENAI) {
      this.openaiImageModel = config.imageModel || 'dall-e-3';
      this.imageModel = this.openaiImageModel; // Alias for compatibility
      console.log('üéØ AIHandler initialized with OpenAI image model:', this.openaiImageModel);
    } else {
      this.imageModel = config.imageModel || 'dall-e-3';
    }
    this.localEndpoint = config.localEndpoint || 'http://localhost:11434';
    this.localModel = config.localModel || 'llama3';
    this.temperature = config.temperature || 0.3;
    this.maxTokens = config.maxTokens || 4000;

    // API Rate Limiting - son istek zamanƒ±nƒ± takip et
    this.lastApiCall = 0;
    this.minDelayBetweenCalls = 1000; // 1 saniye minimum bekleme
    this.requestQueue = [];
    this.isProcessingQueue = false;
  }

  // Rate limiting helper - API √ßaƒürƒ±larƒ± arasƒ±nda minimum bekleme s√ºresi
  async waitForRateLimit() {
    const now = Date.now();
    const timeSinceLastCall = now - this.lastApiCall;

    if (timeSinceLastCall < this.minDelayBetweenCalls) {
      const waitTime = this.minDelayBetweenCalls - timeSinceLastCall;
      console.log(`‚è≥ Rate limit korumasƒ±: ${waitTime}ms bekleniyor...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }

    this.lastApiCall = Date.now();
  }

  async generateText(systemPrompt, userPrompt, options = {}) {
    // Rate limiting kontrol√º
    await this.waitForRateLimit();

    const temperature = options.temperature || this.temperature;
    const maxTokens = options.maxTokens || this.maxTokens;

    try {
      switch (this.provider) {
        case AI_PROVIDERS.OPENAI:
          if (!this.openaiApiKey) {
            throw new Error('OpenAI API key is required');
          }
          return await this.callOpenAI(systemPrompt, userPrompt, temperature, maxTokens);

        case AI_PROVIDERS.GEMINI:
          if (!this.apiKey) {
            throw new Error('Gemini API key is required');
          }
          return await this.callGemini(systemPrompt, userPrompt, temperature, maxTokens);

        case AI_PROVIDERS.LOCAL:
          return await this.callLocalAI(systemPrompt, userPrompt, temperature, maxTokens);

        default:
          throw new Error('Unsupported AI provider: ' + this.provider);
      }
    } catch (error) {
      console.error('AI Generation Error:', error);
      throw error;
    }
  }

  /**
   * Par√ßalƒ± sonu√ßlarƒ± birle≈ütir (2/1, 2/2 formatƒ±ndaki sonu√ßlar i√ßin)
   * @param {Array} chunks - Chunk sonu√ßlarƒ±
   * @returns {Array} Birle≈ütirilmi≈ü chunks
   */
  mergePartialResults(chunks) {
    const merged = [];
    const partialGroups = new Map(); // key: base_id, value: array of parts

    chunks.forEach(chunk => {
      const result = chunk.result;

      // Par√ßalƒ± sonu√ß formatƒ±nƒ± kontrol et: "X/Y" veya "KAPSAMLI ANALƒ∞Z (X/Y"
      const partialMatch = result.match(/(?:KAPSAMLI ANALƒ∞Z|PART|B√ñL√úM)?\s*\(?\s*(\d+)\s*\/\s*(\d+)/i);

      if (partialMatch) {
        const currentPart = parseInt(partialMatch[1]);
        const totalParts = parseInt(partialMatch[2]);

        console.log(`üîç Par√ßalƒ± sonu√ß tespit edildi: ${currentPart}/${totalParts}`);

        // Grup ID'si olu≈ütur (sahne bilgisi veya chunk numarasƒ±)
        const groupId = `${chunk.chunkNumber}_total${totalParts}`;

        if (!partialGroups.has(groupId)) {
          partialGroups.set(groupId, []);
        }

        partialGroups.get(groupId).push({
          ...chunk,
          partNumber: currentPart,
          totalParts: totalParts,
          // Ba≈ülƒ±k kƒ±smƒ±nƒ± temizle
          result: result.replace(/(?:KAPSAMLI ANALƒ∞Z|PART|B√ñL√úM)?\s*\(?\s*\d+\s*\/\s*\d+[^\n]*/i, '').trim()
        });
      } else {
        // Normal sonu√ß, direkt ekle
        merged.push(chunk);
      }
    });

    // Par√ßalƒ± gruplarƒ± birle≈ütir
    partialGroups.forEach((parts, groupId) => {
      // Par√ßa numarasƒ±na g√∂re sƒ±rala
      parts.sort((a, b) => a.partNumber - b.partNumber);

      const totalParts = parts[0].totalParts;

      // T√ºm par√ßalar mevcut mu kontrol et
      if (parts.length === totalParts) {
        console.log(`‚úÖ ${groupId}: ${parts.length}/${totalParts} par√ßa birle≈ütiriliyor`);

        // T√ºm par√ßalarƒ± birle≈ütir
        const mergedResult = parts.map(p => p.result).join('\n\n');

        merged.push({
          ...parts[0],
          result: mergedResult,
          isMerged: true,
          mergedFrom: parts.length
        });
      } else {
        console.warn(`‚ö†Ô∏è ${groupId}: Eksik par√ßa! ${parts.length}/${totalParts}`);
        // Eksik par√ßalar varsa mevcut olanlarƒ± ekle
        parts.forEach(part => merged.push(part));
      }
    });

    return merged;
  }

  async generateImage(prompt, options = {}) {
    // Rate limiting kontrol√º
    await this.waitForRateLimit();

    // Validate prompt parameter
    if (!prompt || typeof prompt !== 'string') {
      throw new Error('Prompt must be a valid string for image generation');
    }

    console.log('Image generation request:', { provider: this.provider, prompt: prompt.substring(0, 50) });

    try {
      // Handle character-specific image generation
      if (options.character) {
        console.log('üé≠ Character image generation for:', options.character);
      }

      // Handle reference image for "similar character" approach
      let enhancedPrompt = prompt;
      if (options.referenceImage) {
        console.log('üñºÔ∏è Reference image provided for character generation');
        enhancedPrompt = prompt + ', use reference image as style guide';
      }

      switch (this.provider) {
        case AI_PROVIDERS.OPENAI:
          const { size = '1024x1024', quality = 'standard', style = 'natural', model = 'dall-e-3' } = options;
          return await this.generateImageOpenAI(enhancedPrompt, { size, quality, style, model });

        case AI_PROVIDERS.GEMINI:
          try {
            return await this.generateImageGemini(enhancedPrompt, options);
          } catch (error) {
            console.error('Gemini image generation failed:', error);
            throw error;
          }

        default:
          throw new Error('Image generation not supported for provider: ' + this.provider);
      }
    } catch (error) {
      console.error('Image Generation Error:', error);
      throw error;
    }
  }

  async analyzeImageGemini(imageData, prompt = "Bu g√∂rseli detaylƒ± bir ≈üekilde analiz et ve a√ßƒ±kla.", options = {}) {
    console.log('Gemini Vision Analysis:', {
      hasGeminiKey: !!this.apiKey,
      imageSize: imageData?.length || 0,
      prompt: prompt.substring(0, 100)
    });

    if (!this.apiKey) {
      throw new Error('Gemini API key gerekli. L√ºtfen ayarlardan API key ekleyin.');
    }

    // Use Gemini 2.5 Flash for vision analysis (fast and accurate)
    const model = options.model || 'gemini-2.5-flash';
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`;

    // Strip data URL prefix if present
    const base64Data = imageData.includes(',') ? imageData.split(',')[1] : imageData;

    const requestBody = {
      contents: [{
        parts: [
          {
            text: prompt
          },
          {
            inline_data: {
              mime_type: options.mimeType || 'image/jpeg',
              data: base64Data
            }
          }
        ]
      }],
      generationConfig: {
        temperature: options.temperature || 0.7,
        maxOutputTokens: options.maxOutputTokens || 2048
      }
    };

    try {
      console.log('üîç Calling Gemini Vision API...');

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody),
        signal: AbortSignal.timeout(options.timeout || 60000) // 1 minute timeout
      });

      console.log('API Response Status:', response.status);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`HTTP ${response.status}: ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      console.log('API Response received');
      console.log('üîç Full API Response:', JSON.stringify(data, null, 2));

      // Gemini API yanƒ±t yapƒ±sƒ±nƒ± parse et
      if (data.candidates && data.candidates.length > 0) {
        const candidate = data.candidates[0];

        // Y√∂ntem 1: content.parts yapƒ±sƒ±
        if (candidate.content && candidate.content.parts) {
          const textParts = candidate.content.parts.filter(part => part.text);
          if (textParts.length > 0) {
            const analysisText = textParts.map(part => part.text).join('\n');
            console.log('‚úÖ Analysis extracted from content.parts');
            return {
              success: true,
              analysis: analysisText,
              provider: 'gemini',
              model: model,
              analyzedAt: new Date().toISOString()
            };
          }
        }

        // Y√∂ntem 2: Doƒürudan text alanƒ±
        if (candidate.text) {
          console.log('‚úÖ Analysis extracted from candidate.text');
          return {
            success: true,
            analysis: candidate.text,
            provider: 'gemini',
            model: model,
            analyzedAt: new Date().toISOString()
          };
        }

        // Y√∂ntem 3: output alanƒ±
        if (candidate.output) {
          console.log('‚úÖ Analysis extracted from candidate.output');
          return {
            success: true,
            analysis: candidate.output,
            provider: 'gemini',
            model: model,
            analyzedAt: new Date().toISOString()
          };
        }
      }

      console.error('‚ùå Unexpected response structure:', JSON.stringify(data, null, 2));
      throw new Error('API\'den ge√ßerli analiz yanƒ±tƒ± alƒ±namadƒ±. L√ºtfen konsol loglarƒ±nƒ± kontrol edin.');
    } catch (error) {
      console.error('Image Analysis Error:', error.message);

      if (error.message?.includes('timeout')) {
        throw new Error('Analiz zaman a≈üƒ±mƒ±na uƒüradƒ±. L√ºtfen tekrar deneyin.');
      } else if (error.message?.includes('403') || error.message?.includes('401')) {
        throw new Error('API anahtarƒ± ge√ßersiz veya yetki yok.');
      }

      throw new Error('G√∂rsel analizi ba≈üarƒ±sƒ±z: ' + error.message);
    }
  }

  async generateImageGemini(prompt, options = {}) {
    if (!this.apiKey) {
      throw new Error('Gemini API key gerekli. Lutfen ayarlardan API key ekleyin.');
    }

    // CRITICAL: ONLY use model from constructor (which comes from store)
    // Never allow options.model to override the store-selected model
    const model = this.geminiImageModel || 'gemini-2.5-flash-image';
    
    if (options.model && options.model !== model) {
      console.warn('‚ö†Ô∏è IGNORED model override attempt:', options.model, '‚Üí Using store model:', model);
    }

    console.log('üéØ Gemini Image Generation with STORE model:', {
      prompt: prompt.substring(0, 100) + '...',
      hasGeminiKey: !!this.apiKey,
      storeModel: model,
      ignoredOptionsModel: options.model || 'none'
    });

    // Updated API endpoint format for Gemini Native and Imagen models
    let apiUrl, requestBody;

    // Check if it's a Gemini Native Image model (uses generateContent)
    if (model.includes('gemini') && model.includes('image')) {
      // Gemini Native Image Generation - uses generateContent API
      apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.apiKey}`;
      
      // Model-specific capabilities based on AI Settings selection
      let modelCapabilities = {
        maxReferenceImages: 3,  // Default for Flash models
        supportedSizes: ['1K'], // Default
        defaultTemperature: 1.0
      };

      // Configure based on selected model
      if (model === 'gemini-3-pro-image-preview') {
        modelCapabilities = {
          maxReferenceImages: 14,  // Pro supports more references
          supportedSizes: ['1K', '2K', '4K'], // Pro supports larger sizes
          defaultTemperature: 1.0
        };
        console.log('üé® Using Gemini 3 Pro Image: 14 refs, up to 4K resolution');
      } else if (model === 'gemini-2.5-flash-image') {
        modelCapabilities = {
          maxReferenceImages: 3,
          supportedSizes: ['1K'], // Flash limited to 1K
          defaultTemperature: 1.0
        };
        console.log('‚ö° Using Gemini 2.5 Flash Image: 3 refs, 1K resolution, faster generation');
      }

      // Validate and adjust image size based on model capabilities
      let requestedSize = options.imageSize || "1K";
      if (!modelCapabilities.supportedSizes.includes(requestedSize)) {
        console.warn(`‚ö†Ô∏è ${model} doesn't support ${requestedSize}, using 1K instead`);
        requestedSize = "1K";
      }

      // Validate temperature (0.0 - 2.0 for image generation)
      let temperature = options.temperature || modelCapabilities.defaultTemperature;
      if (temperature < 0.0 || temperature > 2.0) {
        console.warn(`‚ö†Ô∏è Temperature ${temperature} out of range, clamping to 0.0-2.0`);
        temperature = Math.max(0.0, Math.min(2.0, temperature));
      }

      // Base configuration for all Gemini image models
      const generationConfig = {
        response_modalities: ["IMAGE"],
        temperature: temperature,
        image_config: {
          image_size: requestedSize
        }
      };

      requestBody = {
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: generationConfig,
        safetySettings: [
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_LOW_AND_ABOVE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_LOW_AND_ABOVE"
          }
        ]
      };

      // Add reference images if provided (respecting model limits)
      if (options.referenceImages && Array.isArray(options.referenceImages)) {
        const imageCount = Math.min(options.referenceImages.length, modelCapabilities.maxReferenceImages);
        
        if (options.referenceImages.length > modelCapabilities.maxReferenceImages) {
          console.warn(`‚ö†Ô∏è ${model} supports max ${modelCapabilities.maxReferenceImages} references, using first ${imageCount}`);
        }
        
        for (let i = 0; i < imageCount; i++) {
          const refImage = options.referenceImages[i];
          requestBody.contents[0].parts.push({
            inline_data: {
              mime_type: refImage.mimeType || 'image/jpeg',
              data: refImage.data
            }
          });
        }
        console.log(`üñºÔ∏è Added ${imageCount}/${modelCapabilities.maxReferenceImages} reference images to ${model}`);
      }
    } else {
      // Imagen 4.0 API (v1beta) - uses generateImages
      apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateImages?key=${this.apiKey}`;
      requestBody = {
        prompt: prompt,
        config: {
          number_of_images: options.numberOfImages || 1,
          image_size: options.imageSize || "1K",
          person_generation: "allow_adult"
        }
      };
    }

    try {
      console.log('üì§ API Request:', {
        url: apiUrl.replace(this.apiKey, '***'),
        model: model,
        prompt: (typeof prompt === 'string' ? prompt.substring(0, 100) : String(prompt).substring(0, 100)) + '...',
        requestSize: JSON.stringify(requestBody).length
      });
      
      // Log full request body for debugging
      console.log('üì¶ Full Request Body:', JSON.stringify(requestBody, null, 2));

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody),
        signal: AbortSignal.timeout(options.timeout || 600000) // 10 minutes default timeout for image generation
      });

      console.log('üì• API Response Status:', response.status);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('‚ùå API Error Response:', JSON.stringify(errorData, null, 2));
        throw new Error(`HTTP ${response.status}: ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      console.log('API Response Data Keys:', Object.keys(data || {}));

      // Handle ALL Gemini native image generation models (gemini-3-pro-image, gemini-2.5-flash-image, etc.)
      if (model.includes('gemini') && model.includes('image')) {
        if (data.candidates && data.candidates.length > 0) {
          const candidate = data.candidates[0];
          if (candidate.content && candidate.content.parts) {
            // Find image parts - API uses both inline_data and inlineData formats
            const imageParts = candidate.content.parts.filter(part => 
              part.inline_data || part.inlineData
            );
            
            if (imageParts.length > 0) {
              const imagePart = imageParts[0];
              // Support both camelCase and snake_case formats
              const imageData = imagePart.inline_data || imagePart.inlineData;
              
              console.log(`‚úÖ ${model}: ${imageParts.length} g√∂rsel olu≈üturuldu`);
              return {
                success: true,
                imageData: imageData.data,
                mimeType: imageData.mimeType || imageData.mime_type || 'image/jpeg',
                provider: 'gemini',
                model: model,
                originalPrompt: prompt,
                generatedAt: new Date().toISOString(),
                totalImages: imageParts.length
              };
            }
          }
        }
      }
      // Handle Imagen 4.0 response (legacy format)
      else if (model.includes('imagen')) {
        if (data.generated_images && data.generated_images.length > 0) {
          const generatedImage = data.generated_images[0];
          console.log(`‚úÖ ${model}: G√∂rsel olu≈üturuldu`);
          return {
            success: true,
            imageData: generatedImage.image,
            mimeType: generatedImage.mime_type || 'image/jpeg',
            provider: 'gemini',
            model: model,
            originalPrompt: prompt,
            generatedAt: new Date().toISOString()
          };
        }
      }

      console.error('‚ùå API yanƒ±tƒ± beklenmeyen formatta:', JSON.stringify(data, null, 2));
      throw new Error('API\'den ge√ßerli g√∂rsel yanƒ±tƒ± alƒ±namadƒ±');
    } catch (error) {
      console.error('Image Generation Error:', {
        message: error.message,
        model: model,
      });

      // Hata t√ºrlerini kontrol et
      if (error.message?.includes('404')) {
        throw new Error(`Model bulunamadƒ±: ${model}. Model adƒ±nƒ± kontrol edin.`);
      } else if (error.message?.includes('403') || error.message?.includes('401')) {
        throw new Error('API anahtarƒ± ge√ßersiz veya yetki yok. API anahtarƒ±nƒ±zƒ± kontrol edin.');
      } else if (error.message?.includes('400')) {
        throw new Error('API isteƒüi ge√ßersiz: ' + error.message);
      } else if (error.message?.includes('timeout')) {
        throw new Error('ƒ∞stek zaman a≈üƒ±mƒ±na uƒüradƒ±. L√ºtfen tekrar deneyin.');
      }

      // Gemini Internal Fallback (Imagen 4.0/Gemini 3 -> Imagen 3.0)
      if ((model.includes('imagen-4.0') || model.includes('gemini-3')) &&
        (error.message?.includes('404') || error.message?.includes('400') || error.message?.includes('503') || error.message?.includes('overloaded')) &&
        model !== 'imagen-3.0-generate-001') {
        console.log(`‚ö†Ô∏è ${model} failed, falling back to stable Imagen 3.0...`);
        try {
          return await this.generateImageGemini(prompt, {
            ...options,
            model: 'imagen-3.0-generate-001',
            thinkingLevel: undefined // Imagen 3 doesn't support thinking_level
          });
        } catch (fallbackError) {
          console.log('‚ùå Imagen 3.0 fallback also failed:', fallbackError.message);
          // Allow execution to continue to OpenAI fallback
        }
      }

      // OpenAI DALL-E fallback
      if (this.openaiApiKey) {
        console.log('üîÑ OpenAI DALL-E fallback aktif...');
        try {
          const result = await this.generateImageOpenAI(prompt, {
            model: 'dall-e-3',
            size: options.size || '1024x1024',
            quality: options.quality || 'standard',
            style: options.style || 'natural'
          });

          return {
            ...result,
            provider: 'openai-fallback',
            note: 'Gemini gorsel uretimi basarisiz, OpenAI DALL-E kullanildi'
          };
        } catch (openaiError) {
          throw new Error('Gorsel uretimi basarisiz: ' + openaiError.message);
        }
      }

      throw new Error('Gemini Image API hatasi: ' + error.message);
    }
  }

  async generateImageOpenAI(prompt, options = {}) {
    if (!this.openaiApiKey) {
      throw new Error('OpenAI API key is required for image generation');
    }

    const { model = 'dall-e-3', size = '1024x1024', quality = 'standard', style = 'natural' } = options;

    console.log(`üé® OpenAI Image Generation with ${model}:`, {
      prompt: prompt.substring(0, 100) + '...',
      size, quality, style
    });

    const maxRetries = 3;
    const baseDelay = 3000; // 3 saniye ba≈ülangƒ±√ß bekleme s√ºresi (image generation i√ßin daha uzun)

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîÑ OpenAI Image ${model} - Deneme ${attempt}/${maxRetries}`);

        const response = await fetch('https://api.openai.com/v1/images/generations', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer ' + this.openaiApiKey,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: model,
            prompt: prompt,
            size: size,
            quality: quality,
            style: style,
            n: 1,
          }),
          signal: AbortSignal.timeout(300000) // 5 dakika timeout
        });

        if (!response.ok) {
          const errorData = await response.text();
          const statusCode = response.status;

          if (statusCode === 429) {
            console.log(`‚ö†Ô∏è OpenAI Image API Rate limit (429) - deneme ${attempt}/${maxRetries}`);

            // Son deneme ise hata fƒ±rlat
            if (attempt === maxRetries) {
              throw new Error(`OpenAI Image API rate limit a≈üƒ±ldƒ±. Birka√ß dakika bekleyip tekrar deneyin. Status: ${statusCode}`);
            }

            // Exponential backoff ile bekleme
            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.log(`‚è≥ OpenAI Image rate limit i√ßin ${delay}ms bekleniyor...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          } else {
            // Rate limit deƒüilse direkt hata fƒ±rlat
            throw new Error(`OpenAI Image API Error: HTTP ${statusCode}: ${errorData}`);
          }
        }

        const data = await response.json();
        console.log(`‚úÖ OpenAI Image ${model} ba≈üarƒ±lƒ±!`);

        if (data && data.data && data.data.length > 0) {
          const imageData = data.data[0];
          return {
            success: true,
            imageUrl: imageData.url,
            provider: 'openai',
            model: model,
            revisedPrompt: imageData.revised_prompt || prompt,
            originalPrompt: prompt,
            generatedAt: new Date().toISOString(),
          };
        }

        throw new Error('No image data received from OpenAI');

      } catch (error) {
        console.log(`‚ùå OpenAI Image ${model} deneme ${attempt} ba≈üarƒ±sƒ±z:`, error.message);

        // Network error veya 429/rate limit hatasƒ±nƒ± kontrol et
        const isRateLimit = error.message.includes('429') ||
          error.message.includes('Too Many Requests') ||
          error.message.includes('rate limit') ||
          (error.name === 'TypeError' && error.message.includes('fetch'));

        if (!isRateLimit) {
          // Rate limit deƒüilse hemen fƒ±rlat
          throw error;
        }

        // Son deneme ise hata fƒ±rlat
        if (attempt === maxRetries) {
          throw new Error(`OpenAI Image API: Maksimum deneme sayƒ±sƒ±na ula≈üƒ±ldƒ±. ${error.message}`);
        }

        // Exponential backoff ile bekleme
        const delay = baseDelay * Math.pow(2, attempt - 1);
        console.log(`‚è≥ OpenAI Image retry i√ßin ${delay}ms bekleniyor...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  async callOpenAI(systemPrompt, userPrompt, temperature, maxTokens) {
    if (!this.openaiApiKey) {
      throw new Error('OpenAI API key is required');
    }

    // API key debug bilgisi
    const keyPrefix = this.openaiApiKey.substring(0, 10);
    const keySuffix = this.openaiApiKey.substring(this.openaiApiKey.length - 5);
    console.log(`üîë Using OpenAI API key: ${keyPrefix}...${keySuffix} (length: ${this.openaiApiKey.length})`);
    console.log(`üéØ Using OpenAI model: ${this.model}`);

    const maxRetries = 3;
    const baseDelay = 2000; // 2 saniye ba≈ülangƒ±√ß bekleme s√ºresi

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîÑ OpenAI ${this.model} - Deneme ${attempt}/${maxRetries}`);

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer ' + this.openaiApiKey,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: this.model,
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userPrompt }
            ],
            temperature: temperature,
            max_tokens: maxTokens,
          }),
          signal: AbortSignal.timeout(300000) // 5 dakika timeout
        });

        if (!response.ok) {
          const errorData = await response.text();
          const statusCode = response.status;

          if (statusCode === 429) {
            console.log(`‚ö†Ô∏è OpenAI Rate limit (429) - deneme ${attempt}/${maxRetries}`);

            // Son deneme ise hata fƒ±rlat
            if (attempt === maxRetries) {
              throw new Error(`OpenAI API rate limit a≈üƒ±ldƒ±. Birka√ß dakika bekleyip tekrar deneyin. Status: ${statusCode}`);
            }

            // Exponential backoff ile bekleme
            const delay = baseDelay * Math.pow(2, attempt - 1);
            console.log(`‚è≥ OpenAI rate limit i√ßin ${delay}ms bekleniyor...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue; // Bir sonraki deneme i√ßin loop'a devam et
          } else {
            // Rate limit deƒüilse direkt hata fƒ±rlat
            throw new Error(`OpenAI API Error: HTTP ${statusCode}: ${errorData}`);
          }
        }

        const data = await response.json();
        console.log(`‚úÖ OpenAI ${this.model} ba≈üarƒ±lƒ±!`);
        return data.choices[0].message.content;

      } catch (error) {
        console.log(`‚ùå OpenAI ${this.model} deneme ${attempt} ba≈üarƒ±sƒ±z:`, error.message);

        // Network error veya 429/rate limit hatasƒ±nƒ± kontrol et
        const isRateLimit = error.message.includes('429') ||
          error.message.includes('Too Many Requests') ||
          error.message.includes('rate limit') ||
          (error.name === 'TypeError' && error.message.includes('fetch'));

        if (!isRateLimit) {
          // Rate limit deƒüilse hemen fƒ±rlat
          throw error;
        }

        // Son deneme ise hata fƒ±rlat
        if (attempt === maxRetries) {
          throw new Error(`OpenAI API: Maksimum deneme sayƒ±sƒ±na ula≈üƒ±ldƒ±. ${error.message}`);
        }

        // Exponential backoff ile bekleme
        const delay = baseDelay * Math.pow(2, attempt - 1);
        console.log(`‚è≥ OpenAI retry i√ßin ${delay}ms bekleniyor...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  async callGemini(systemPrompt, userPrompt, temperature, maxTokens) {
    if (!this.apiKey) {
      throw new Error('Google API key is required');
    }

    // API key debug bilgisi
    const keyPrefix = this.apiKey.substring(0, 10);
    const keySuffix = this.apiKey.substring(this.apiKey.length - 5);
    console.log(`üîë Using Gemini API key: ${keyPrefix}...${keySuffix} (length: ${this.apiKey.length})`);

    // Sadece se√ßili modeli kullan - fallback yok
    const selectedModel = this.model;
    console.log(`üéØ Using selected model: ${selectedModel}`);

    try {
      // API v1beta endpoint - More stable for Gemini models
      const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/' + selectedModel + ':generateContent?key=' + this.apiKey;

      // Debug logging
      console.log('Gemini API Debug:', {
        model: selectedModel,
        apiUrl: apiUrl.replace(this.apiKey, '***'),
        systemPromptLength: systemPrompt ? systemPrompt.length : 0,
        userPromptLength: userPrompt ? userPrompt.length : 0
      });

      const result = await this.makeGeminiRequestWithRetry(apiUrl, systemPrompt, userPrompt, temperature, maxTokens, selectedModel);
      console.log(`‚úÖ ${selectedModel} ba≈üarƒ±lƒ±!`);
      return result;

    } catch (error) {
      console.log(`‚ùå ${selectedModel} ba≈üarƒ±sƒ±z:`, error.message);
      throw error;
    }
  }

  async makeGeminiRequestWithRetry(apiUrl, systemPrompt, userPrompt, temperature, maxTokens, modelName) {
    const maxRetries = 3;
    const baseDelay = 3000;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîÑ ${modelName} - Deneme ${attempt}/${maxRetries}`);
        return await this.makeGeminiRequest(apiUrl, systemPrompt, userPrompt, temperature, maxTokens);
      } catch (error) {
        console.log(`‚ùå ${modelName} deneme ${attempt} ba≈üarƒ±sƒ±z:`, error.message);

        // Son deneme ise hata fƒ±rlat
        if (attempt === maxRetries) {
          throw error;
        }

        // Exponential backoff: 3s, 6s, 12s
        const delay = baseDelay * Math.pow(2, attempt - 1);
        console.log(`‚è≥ [${modelName}] Yeniden deneme - ${Math.round(delay / 1000)}s bekleniyor... (${attempt}/${maxRetries})`);

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  async makeGeminiRequest(apiUrl, systemPrompt, userPrompt, temperature, maxTokens) {
    // Gemini v1beta API format
    const requestBody = {
      contents: [
        {
          role: 'user',
          parts: [
            {
              text: systemPrompt ? `${systemPrompt}\n\n${userPrompt}` : userPrompt
            }
          ]
        }
      ],
      generationConfig: {
        temperature: temperature || 0.7,
        maxOutputTokens: maxTokens || 8192,
        topP: 0.95,
        topK: 40,
      },
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_LOW_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_LOW_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_LOW_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_LOW_AND_ABOVE"
        }
      ]
    };

    // Direct API call using fetch for better browser compatibility
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 300000); // 5 dakika timeout

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));

        // √ñzel hata mesajlarƒ±
        let errorMessage = `HTTP ${response.status}: ${errorData.error?.message || response.statusText}`;

        if (response.status === 503) {
          errorMessage = `The model is overloaded. Please try again later.`; // Retry mekanizmasƒ± i√ßin standart mesaj
        } else if (response.status === 429) {
          errorMessage = `üîÑ Rate limit korumasƒ± aktif - ƒ∞stekler yava≈ülatƒ±lƒ±yor. Normal bir durumdur.`;
        } else if (response.status === 508) {
          errorMessage = `‚è∞ Gemini API g√ºnl√ºk limitine ula≈üƒ±ldƒ±. L√ºtfen yarƒ±n tekrar deneyin.`;
        } else if (errorData.error?.message?.includes('quota')) {
          errorMessage = `‚ö†Ô∏è API quota limitine ula≈üƒ±ldƒ±. Daha az sƒ±klƒ±kla istek g√∂nderin.`;
        }

        throw new Error(errorMessage);
      }

      const data = await response.json();
      if (data.candidates && data.candidates.length > 0) {
        const candidate = data.candidates[0];

        // Check if response was blocked
        if (candidate.finishReason === 'SAFETY') {
          throw new Error('Yanƒ±t Gemini g√ºvenlik filtreleri tarafƒ±ndan engellendi. L√ºtfen isteƒüinizi yeniden ifade edin.');
        }

        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          console.log(`‚úÖ Gemini 3 Pro ba≈üarƒ±lƒ±!`);
          return candidate.content.parts[0].text;
        }
      }

      throw new Error('Gemini 3 Pro API\'den ge√ßerli yanƒ±t alƒ±namadƒ±');
    } catch (error) {
      console.error(`‚ùå Gemini 3 Pro API Error:`, {
        message: error.message,
        name: error.name
      });

      // HTTP hata kodlarƒ±nƒ± kontrol et
      if (error.message.includes('HTTP 503') || error.message.includes('overloaded')) {
        throw new Error(`HTTP 503: The model is overloaded. Please try again later.`); // Retry i√ßin standart mesaj
      }
      
      if (error.message.includes('HTTP 429') || error.message.includes('quota')) {
        throw new Error(`Gemini API kullanƒ±m limitine ula≈üƒ±ldƒ±. L√ºtfen birka√ß dakika bekleyip tekrar deneyin veya API anahtarƒ±nƒ±zƒ± kontrol edin.`);
      }

      if (error.message.includes('HTTP 401')) {
        throw new Error(`Gemini API anahtarƒ± ge√ßersiz. L√ºtfen API anahtarƒ±nƒ±zƒ± kontrol edin.`);
      }

      if (error.message.includes('HTTP 403')) {
        throw new Error(`Gemini API eri≈üim izni yok. API anahtarƒ± yetkilerini kontrol edin.`);
      }

      // Timeout/Abort hatalarƒ±nƒ± √∂zel olarak i≈üle
      if (error.name === 'AbortError') {
        throw new Error(`Gemini 3 Pro API zaman a≈üƒ±mƒ±: ƒ∞stek √ßok uzun s√ºrd√º (5+ dakika). L√ºtfen daha kƒ±sa bir metin deneyin veya tekrar deneyin.`);
      }

      // Network hatalarƒ±nƒ± i≈üle
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        throw new Error(`Gemini 3 Pro API'ye baƒülanƒ±lamƒ±yor: ${error.message}`);
      }

      throw new Error(`Gemini 3 Pro API Hatasƒ±: ${error.message || 'Bilinmeyen hata'}`);
    }
  }

  async callLocalAI(systemPrompt, userPrompt, temperature, maxTokens) {
    const endpoint = this.localEndpoint.endsWith('/')
      ? this.localEndpoint + "api/generate"
      : this.localEndpoint + "/api/generate";

    const combinedPrompt = systemPrompt + "\n\n" + userPrompt;

    const response = await axios.post(
      endpoint,
      {
        model: this.localModel,
        prompt: combinedPrompt,
        stream: false,
        options: {
          temperature: temperature,
          num_predict: maxTokens,
        }
      },
      {
        headers: {
          'Content-Type': 'application/json',
        },
        timeout: 300000, // 5 dakika - uzun analizler i√ßin
      }
    );

    return response.data.response;
  }

  /**
   * Parse JSON response from AI
   * Cleans markdown, extracts JSON, and parses it
   * @param {string} responseText - Raw AI response
   * @returns {object} Parsed JSON object
   */
  parseJSONResponse(responseText) {
    try {
      // 1. Clean the response text
      let jsonText = responseText.trim();
      
      console.log('üîç Parsing JSON response, original length:', jsonText.length);
      
      // Remove common AI explanation patterns
      jsonText = jsonText.replace(/^(Here is|Here's|ƒ∞≈üte|Bu|Yanƒ±t|Response|Result|Sonu√ß|Analiz)[^\n]*\n*/gi, '');
      jsonText = jsonText.replace(/^(The|This|Bu)\s+(JSON|response|yanƒ±t|sonu√ß)[^\n]*\n*/gi, '');
      
      // Remove markdown code blocks (multiple passes for nested blocks)
      jsonText = jsonText.replace(/```json\s*/gi, '');
      jsonText = jsonText.replace(/```javascript\s*/gi, '');
      jsonText = jsonText.replace(/```\s*/g, '');
      
      // Remove any leading/trailing non-JSON text
      jsonText = jsonText.replace(/^[^{[]*/, ''); // Remove everything before first { or [
      jsonText = jsonText.replace(/[^}\]]*$/, ''); // Remove everything after last } or ]
      
      // Extra cleaning: Remove explanatory text that might be embedded
      const lines = jsonText.split('\n');
      const cleanLines = lines.filter(line => {
        const trimmed = line.trim();
        // Keep lines that are part of JSON structure
        if (!trimmed) return true; // Empty lines are OK in JSON
        if (trimmed.match(/^[{}\[\],:"]/)) return true; // Starts with JSON chars
        if (trimmed.match(/^"[^"]*":/)) return true; // Key-value pair
        if (trimmed.match(/^"[^"]*",?$/)) return true; // String value
        if (trimmed.match(/^\d+,?$/)) return true; // Number value
        if (trimmed.match(/^(true|false|null),?$/)) return true; // Boolean/null
        // Remove lines that look like explanations
        if (trimmed.match(/^(note|not|a√ßƒ±klama|explanation|this|bu|the)/i)) return false;
        return true;
      });
      jsonText = cleanLines.join('\n');
      
      // Find the actual JSON structure
      const firstBrace = jsonText.indexOf('{');
      const firstBracket = jsonText.indexOf('[');
      const lastBrace = jsonText.lastIndexOf('}');
      const lastBracket = jsonText.lastIndexOf(']');
      
      let startPos = -1;
      let endPos = -1;
      
      // Determine if it's an object {...} or array [...]
      if (firstBrace !== -1 && (firstBracket === -1 || firstBrace < firstBracket)) {
        // It's an object
        startPos = firstBrace;
        endPos = lastBrace + 1;
      } else if (firstBracket !== -1) {
        // It's an array
        startPos = firstBracket;
        endPos = lastBracket + 1;
      }
      
      if (startPos === -1 || endPos === -1 || startPos >= endPos) {
        throw new Error('No valid JSON structure found in response');
      }
      
      jsonText = jsonText.substring(startPos, endPos).trim();
      
      console.log('üßπ Cleaned JSON text length:', jsonText.length);
      console.log('üìù First 200 chars:', jsonText.substring(0, 200));
      
      // 2. Parse the JSON
      const parsed = JSON.parse(jsonText);
      
      console.log('‚úÖ JSON parsed successfully');
      return parsed;
      
    } catch (error) {
      console.error('‚ùå JSON parsing failed:', error.message);
      console.log('üìÑ Raw response (first 500 chars):', responseText.substring(0, 500));
      console.log('üìÑ Raw response (last 500 chars):', responseText.substring(Math.max(0, responseText.length - 500)));
      throw new Error(`JSON parsing failed: ${error.message}`);
    }
  }

  /**
   * Analyze text with custom prompts
   * Used by AnalysisPanel for multi-analysis workflow
   * @param {string} text - The text to analyze
   * @param {object} options - Analysis options
   */
  async analyzeWithCustomPrompt(text, options = {}) {
    console.log('‚úÖ analyzeWithCustomPrompt called!', { textLength: text?.length, options });

    const {
      systemPrompt = 'Sen bir senaryo analiz uzmanƒ±sƒ±n.',
      userPrompt = '',
      useChunking = false,
      onProgress = null,
      promptFormat = 'text' // 'json' or 'text'
    } = options;

    // Enable chunking for moderately long texts (>15000 chars) to analyze complete scripts
    if (!useChunking && text.length < 15000) {
      // Direct analysis for shorter texts
      const fullPrompt = userPrompt.replace(/\{\{text\}\}/g, text);

      if (onProgress) {
        onProgress({ message: 'Analiz yapƒ±lƒ±yor...', progress: 50 });
      }

      const result = await this.generateText(systemPrompt, fullPrompt);

      if (onProgress) {
        onProgress({ message: 'Tamamlandƒ±', progress: 100 });
      }

      // Parse JSON if format is JSON
      if (promptFormat === 'json') {
        try {
          return this.parseJSONResponse(result);
        } catch (error) {
          console.warn('JSON parsing failed for short text, returning raw text:', error);
          return result; // Fallback to raw text
        }
      }

      return result;
    }

    // Use chunking for long texts or when explicitly requested
    console.log(`üìù Script length: ${text.length} characters - Using chunking for complete analysis`);

    // Get optimal chunk size for current Gemini model
    const chunkOptions = getOptimalChunkSize('gemini', this.model || 'gemini-2.5-flash');
    const chunks = splitTextForAnalysis(text, {
      ...chunkOptions,
      maxTokens: 6000,  // Larger chunks for better context
      overlapTokens: 600, // Proportional overlap
      preserveScenes: true // Maintain screenplay structure
    });

    const totalChunks = chunks.length;
    console.log(`üîÑ Script split into ${totalChunks} chunks for complete analysis`);

    let chunkResults = [];

    // Analyze each chunk with scene context
    for (let i = 0; i < totalChunks; i++) {
      const chunk = chunks[i];
      const chunkNumber = i + 1;

      if (onProgress) {
        onProgress({
          message: `B√∂l√ºm ${chunkNumber}/${totalChunks} analiz ediliyor... (${chunk.scenes?.length || 0} sahne)`,
          progress: (i / totalChunks) * 80, // Leave 20% for final synthesis
          chunkNumber,
          totalChunks,
          currentChunk: {
            scenes: chunk.scenes?.length || 0,
            wordCount: chunk.wordCount,
            type: chunk.type
          }
        });
      }

      console.log(`üîç Analyzing chunk ${chunkNumber}/${totalChunks}: ${chunk.wordCount} words, ${chunk.scenes?.length || 0} scenes`);

      // Create chunk-specific prompt with context
      const chunkContext = chunk.scenes?.length > 0 ?
        `\n\nBU B√ñL√úM HAKKƒ∞NDA:\n- B√∂l√ºm ${chunkNumber}/${totalChunks}\n- ${chunk.scenes.length} sahne i√ßeriyor\n- ${chunk.type === 'scene-based' ? 'Sahne sƒ±nƒ±rlarƒ± korundu' : 'Paragraf bazlƒ± b√∂l√ºmleme'}\n` :
        `\n\nBU B√ñL√úM HAKKƒ∞NDA:\n- B√∂l√ºm ${chunkNumber}/${totalChunks}\n- ${chunk.wordCount} kelime\n`;

      const chunkPrompt = userPrompt.replace(/\{\{text\}\}/g, chunk.text) + chunkContext;

      try {
        console.log(`‚è≥ Starting analysis for chunk ${chunkNumber} (${chunk.tokenEstimate} tokens estimated)`);

        const chunkResult = await this.generateText(systemPrompt, chunkPrompt);

        chunkResults.push({
          chunkIndex: i,
          chunkNumber,
          result: chunkResult,
          scenes: chunk.scenes || [],
          wordCount: chunk.wordCount,
          tokenEstimate: chunk.tokenEstimate,
          type: chunk.type
        });

        console.log(`‚úÖ Chunk ${chunkNumber} completed: ${chunkResult.length} characters`);
      } catch (error) {
        console.error(`‚ùå Error analyzing chunk ${chunkNumber}:`, error);

        // Daha detaylƒ± hata tanƒ±mlarƒ±
        const isTimeoutError = error.message?.includes('timeout') || error.code === 'ECONNABORTED';
        const isQuotaError = error.message?.includes('quota') || error.message?.includes('429') || error.message?.includes('508');
        const isRateLimit = error.message?.includes('Too Many Requests');
        const isAPIError = error.response?.status >= 400;

        let errorMessage = `B√∂l√ºm ${chunkNumber} analiz hatasƒ±`;

        if (isQuotaError) {
          errorMessage += ' (API quota limiti a≈üƒ±ldƒ± - birka√ß dakika bekleyin)';
        } else if (isRateLimit) {
          errorMessage += ' (√áok fazla istek - 30 saniye bekleyin)';
        } else if (isTimeoutError) {
          errorMessage += ' (Zaman a≈üƒ±mƒ± - b√∂l√ºm √ßok b√ºy√ºk olabilir)';
        } else if (isAPIError) {
          errorMessage += ` (API Hatasƒ±: ${error.response?.status})`;
        } else {
          errorMessage += `: ${error.message}`;
        }

        chunkResults.push({
          chunkIndex: i,
          chunkNumber,
          result: errorMessage,
          error: true,
          errorType: isQuotaError ? 'quota' : (isRateLimit ? 'rate_limit' : (isTimeoutError ? 'timeout' : (isAPIError ? 'api' : 'unknown'))),
          scenes: chunk.scenes || [],
          wordCount: chunk.wordCount
        });
      }
    }

    // Final synthesis step - combine all chunk analyses
    if (onProgress) {
      onProgress({
        message: 'T√ºm b√∂l√ºmler analiz edildi, sentez yapƒ±lƒ±yor...',
        progress: 85,
        phase: 'synthesis'
      });
    }

    console.log(`üéØ Synthesizing ${chunkResults.length} chunk analyses into final result`);

    // Filter out invalid chunks and check for meaningful content
    const successfulChunks = chunkResults.filter(cr => {
      if (cr.error) return false;

      // Skip chunks with only synthesis prompts or template text
      const result = cr.result.toLowerCase();
      if (result.includes('b√∂l√ºm analiz sonu√ßlarƒ±') ||
        result.includes('***') ||
        result.includes('l√ºtfen yukarƒ±daki') ||
        result.length < 50) {
        console.warn(`Skipping invalid chunk ${cr.chunkNumber}: contains template text`);
        return false;
      }
      return true;
    });

    const errorCount = chunkResults.length - successfulChunks.length;

    // If no valid chunks, return fallback
    if (successfulChunks.length === 0) {
      console.warn('No valid chunks found, returning error message');
      return 'Analiz sƒ±rasƒ±nda teknik bir sorun olu≈ütu. L√ºtfen daha kƒ±sa bir metin ile tekrar deneyin.';
    }

    // üîÑ AKILLI Bƒ∞RLE≈ûTƒ∞RME: Par√ßalƒ± sonu√ßlarƒ± kontrol et ve birle≈ütir
    console.log('üîç Par√ßalƒ± sonu√ß kontrol√º yapƒ±lƒ±yor...');
    const mergedChunks = this.mergePartialResults(successfulChunks);
    console.log(`‚úÖ ${successfulChunks.length} par√ßa -> ${mergedChunks.length} birle≈ütirilmi≈ü sonu√ß`);

    const synthesisPrompt = `Bu senaryonun ${mergedChunks.length} farklƒ± par√ßada yapƒ±lan analizlerini tek kapsamlƒ± analiz haline getir:

${mergedChunks.map((chunk, idx) =>
      `${idx + 1}. PAR√áA ANALƒ∞Zƒ∞:\n${chunk.result.substring(0, 1000)}${chunk.result.length > 1000 ? '...' : ''}\n`
    ).join('\n')}\n\nYukarƒ±daki par√ßa analizlerini birle≈ütirerek tek final analiz olu≈ütur:`;

    // Additional safety check for synthesis prompt length
    if (synthesisPrompt.length > 20000) {
      console.warn('Synthesis prompt too long, using fallback concatenation');
      const fallbackResult = mergedChunks.map(chunk => chunk.result).join('\n\n---\n\n');

      if (onProgress) {
        onProgress({
          message: 'Analiz tamamlandƒ± (par√ßa birle≈ütirme)',
          progress: 100,
          phase: 'completed-fallback'
        });
      }

      return fallbackResult;
    }

    try {
      const finalResult = await this.generateText(
        'Sen uzman bir analiz edit√∂r√ºs√ºn. Par√ßa analizlerini tek tutarlƒ± analiz haline getirirsin.',
        synthesisPrompt
      );

      // Check if result contains synthesis prompt artifacts
      const resultLower = finalResult.toLowerCase();
      if (resultLower.includes('par√ßa analizi') ||
        resultLower.includes('yukarƒ±daki') ||
        resultLower.includes('birle≈ütir')) {
        console.warn('Synthesis result contains prompt artifacts, using fallback');
        throw new Error('Synthesis returned prompt text');
      }

      if (onProgress) {
        onProgress({
          message: 'Kapsamlƒ± analiz tamamlandƒ±!',
          progress: 100,
          phase: 'completed',
          chunksAnalyzed: successfulChunks.length,
          totalChunks: totalChunks,
          errors: errorCount
        });
      }

      console.log(`‚úÖ Complete script analysis finished: ${successfulChunks.length}/${totalChunks} chunks successful`);

      // Parse JSON if format is JSON
      if (promptFormat === 'json') {
        try {
          return this.parseJSONResponse(finalResult);
        } catch (error) {
          console.warn('JSON parsing failed for synthesis result, returning raw text:', error);
          return finalResult; // Fallback to raw text
        }
      }

      return finalResult;

    } catch (synthesisError) {
      console.error('‚ùå Synthesis error:', synthesisError);

      // Fallback: return concatenated results
      const fallbackResult = successfulChunks.map(chunk => chunk.result).join('\n\n---\n\n');

      if (onProgress) {
        onProgress({
          message: 'Analiz tamamlandƒ± (sentez hatasƒ±, ham sonu√ßlar d√∂nd√ºr√ºld√º)',
          progress: 100,
          phase: 'completed-fallback'
        });
      }

      const fallbackText = `KAPSAMLI ANALƒ∞Z (${successfulChunks.length}/${totalChunks} b√∂l√ºm):\n\n` + fallbackResult;
      
      // Try to parse fallback if JSON format expected
      if (promptFormat === 'json') {
        try {
          return this.parseJSONResponse(fallbackText);
        } catch (error) {
          console.warn('JSON parsing failed for fallback result, returning raw text');
          return fallbackText;
        }
      }

      return fallbackText;
    }
  }

  /**
   * Generate images using Gemini 3 Pro Image Preview
   * Supports reference images (up to 14 images)
   * Updated to match official Gemini 3 Pro Image Preview API format (November 2025)
   */
  async _deprecated_generateImage(prompt, options = {}) {
    // Only support Gemini for image generation currently
    if (this.provider !== AI_PROVIDERS.GEMINI) {
      throw new Error('G√∂rsel √ºretme sadece Gemini provider ile desteklenmektedir');
    }

    if (!this.apiKey) {
      throw new Error('Gemini API anahtarƒ± gerekli');
    }

    if (!prompt || typeof prompt !== 'string' || !prompt.trim()) {
      throw new Error('G√∂rsel a√ßƒ±klamasƒ± (prompt) gerekli');
    }

    try {
      console.log('üé® Generating image with Gemini 3 Pro Image Preview...');

      // Use the exact model name from Google documentation
      const imageModel = 'gemini-3-pro-image-preview';

      // Prepare request body for Gemini 3 Pro Image Preview API
      // Based on official Google documentation format
      const requestBody = {
        contents: [{
          parts: []
        }],
        generationConfig: {
          temperature: options.temperature || 0.7,
          topP: 0.8,
          topK: 40,
          maxOutputTokens: 8192,
          // Response modalities MUST be at this level for Gemini 3 Pro Image
          response_modalities: ['TEXT', 'IMAGE']
        },
        safetySettings: [
          { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
          { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
          { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
          { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' }
        ]
      };

      // Add image configuration if specified (CORRECT PLACEMENT in generationConfig)
      if (options.imageSize) {
        requestBody.generationConfig.image_config = {};

        // Valid values: "1K", "2K", "4K" (note: capital K required)
        requestBody.generationConfig.image_config.image_size = options.imageSize;
      }

      // Add text prompt first
      requestBody.contents[0].parts.push({
        text: prompt.trim()
      });

      // Add reference images if provided (up to 14 images as per Gemini 3 Pro spec)
      if (options.referenceImages && Array.isArray(options.referenceImages)) {
        const maxImages = Math.min(options.referenceImages.length, 14);

        for (let i = 0; i < maxImages; i++) {
          const refImage = options.referenceImages[i];
          if (refImage && refImage.data && refImage.mimeType) {
            let base64Data = refImage.data;

            // Remove data URL prefix if present (data:image/png;base64,)
            if (base64Data.includes(',')) {
              base64Data = base64Data.split(',')[1];
            }

            requestBody.contents[0].parts.push({
              inline_data: {
                mime_type: refImage.mimeType,
                data: base64Data
              }
            });
          }
        }

        console.log(`üì∏ Added ${maxImages} reference image(s) to Gemini 3 Pro Image request`);
      }

      // Use the correct API endpoint format for Gemini 3 Pro Image Preview
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${imageModel}:generateContent`;

      console.log('üåê Calling Gemini 3 Pro Image API...', {
        model: imageModel,
        endpoint: url,
        hasReferenceImages: !!(options.referenceImages?.length),
        imageSize: options.imageSize
      });

      const response = await axios.post(url, requestBody, {
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': this.apiKey
        },
        timeout: 180000 // 3 minutes timeout for image generation
      });

      console.log('üì° Gemini 3 Pro Image API Response Status:', response.status);

      if (response.status !== 200) {
        throw new Error(`Gemini API returned status ${response.status}: ${response.statusText}`);
      }

      const data = response.data;
      console.log('üì¶ API Response structure:', {
        hasCandidates: !!(data.candidates),
        candidatesLength: data.candidates?.length || 0,
        firstCandidateKeys: data.candidates?.[0] ? Object.keys(data.candidates[0]) : [],
        finishReason: data.candidates?.[0]?.finishReason
      });

      if (data.candidates && data.candidates.length > 0) {
        const candidate = data.candidates[0];

        // Check if response was blocked
        if (candidate.finishReason === 'SAFETY') {
          throw new Error('G√∂rsel √ºretimi Gemini g√ºvenlik filtreleri tarafƒ±ndan engellendi. L√ºtfen a√ßƒ±klamayƒ± deƒüi≈ütirin.');
        }

        if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
          // Look for image data in parts
          for (const part of candidate.content.parts) {
            // Check for both inline_data and inlineData formats
            const imageData = part.inline_data || part.inlineData;
            if (imageData && imageData.data && imageData.mimeType) {
              console.log('‚úÖ Image generated successfully!');
              return {
                success: true,
                imageData: imageData.data,
                mimeType: imageData.mimeType,
                provider: 'gemini-3-pro-image',
                model: imageModel,
                prompt: prompt,
                timestamp: new Date().toISOString()
              };
            }

            // Also check for thought_signature which might contain image data
            if (part.thought_signature) {
              console.log('ü§î Found thought signature (thinking process)');
              // This might be part of the thinking process, continue checking
            }
          }

          // Log all parts for debugging
          console.log('üîç Response parts analysis:');
          candidate.content.parts.forEach((part, index) => {
            console.log(`Part ${index}:`, {
              hasText: !!part.text,
              hasInlineData: !!(part.inline_data || part.inlineData),
              hasThoughtSignature: !!part.thought_signature,
              isThought: !!part.thought,
              keys: Object.keys(part)
            });
          });
        }
      }

      // Enhanced error message with response structure
      const responseStructure = JSON.stringify(data, null, 2).substring(0, 500);
      throw new Error(`Gemini 3 Pro Image API'den ge√ßerli g√∂rsel verisi alƒ±namadƒ±. Response: ${responseStructure}...`);
    } catch (error) {
      console.error('‚ùå Gemini Image Generation Error:', {
        message: error.message,
        name: error.name,
        prompt: prompt.substring(0, 100) + '...',
        responseStatus: error.response?.status,
        responseData: error.response?.data
      });

      // Provide more specific error messages
      if (error.response) {
        const status = error.response.status;
        const errorData = error.response.data;

        if (status === 400) {
          const errorMsg = errorData?.error?.message || 'API isteƒüi hatalƒ±';
          throw new Error(`üö´ Ge√ßersiz istek (400): ${errorMsg}`);
        } else if (status === 401) {
          throw new Error('üîë Gemini API anahtarƒ± ge√ßersiz veya eksik');
        } else if (status === 403) {
          throw new Error('üö´ Gemini API eri≈üimi reddedildi. Kotanƒ±zƒ± veya izinlerinizi kontrol edin.');
        } else if (status === 404) {
          throw new Error(`üîç Model bulunamadƒ±: ${imageModel}. Model adƒ±nƒ± kontrol edin.`);
        } else if (status === 429) {
          throw new Error('‚è≥ Gemini API rate limit a≈üƒ±ldƒ±. L√ºtfen biraz bekleyin.');
        } else {
          throw new Error(`üåê Gemini API hatasƒ± (${status}): ${errorData?.error?.message || error.message}`);
        }
      }

      throw error;
    }
  }
}

export default AIHandler;